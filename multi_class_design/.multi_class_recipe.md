.

## 1. Describe the Problem

As a user
So that I can record my experiences
I want to keep a regular diary

As a user
So that I can reflect on my experiences
I want to read my past diary entries

As a user
So that I can reflect on my experiences in my busy day
I want to select diary entries to read based on how much time I have and my reading speed

As a user
So that I can keep track of my tasks
I want to keep a todo list along with my diary

As a user
So that I can keep track of my contacts
I want to see a list of all of the mobile phone numbers in all my diary entries

## Nouns

diary
diary-entry / experience

task
todo - list

contact
list of mobile numbers


## Verbs

record experience
reflect / read past diary entries
select entry > how much time i have, reading speed
keep track of tasks
keep track contacts > see list of mobile numbers 


## 2. Design the Class Interface

_Include the initializer, public properties, and public methods with all parameters, return values, and side-effects._

```python
class Diary():
    #init
    #parameters -> none
    #returns -> none
    #sides -> initialise empty lists:   entries_list = []
                                        # tasks_list = TaskList()
                                        # contact_list = []  
    def __init__(self):
        pass

    #entries
    #parameters -> none
    #returns -> all entries from entries_list
    #sides -> none
    def entries(self):
        pass

    #add_entry
    #parameters -> entry : DiaryEntry
    #returns -> none
    #sides -> appends entry to entries_list
    def add_entry(self, entry):
        pass

    #best_entry
    #parameters -> wpm: int
    #           -> minutes: int
    #returns -> entry that is closest in time to read, without going over
    #sides -> none
    def best_entry(self, wpm, minutes):
        pass

    #tasks
    #parameters -> none
    #returns -> list of tasks, and whether they have been completed or not
    #sides -> none
    def tasks(self):
        pass

    #contacts
    #parameters -> none
    #returns -> list of contacts
    #sides -> none
    def contacts(self):
        pass



class DiaryEntry():
    #init
    #params -> title: str, contents: str
    #returns -> none
    #sides -> instantiates self
    def __init__(self, title, contents):
        pass

    #get_title
    #params -> none
    #returns -> self.title
    #sides -> none
    def get_title(self):
        pass

    #get_contents
    #params -> none
    #returns -> self.contents
    #sides -> none
    def get_contents(self):
        pass

    #count_words
    #params -> none
    #returns -> number of words in contents
    #sides -> none  
    def count_words(self):
        pass

    #reading_time
    #params -> words: int, wpm: int
    #returns -> int: time to read entry in minutes
    #sides -> none
    def reading_time(wpm, word_count):
        pass


class Contact():
    #init
    #params -> name: str "", number: str
    #returns -> none
    # sides -> none
    def __init__(self, name, number):
        pass

    #get_contact
    #params -> none
    #returns -> str: f"{name}, {number}"
    def get_contact(self):
        pass

class ContactList():
    #init
    #params -> none
    #returns -> none
    #sides -> instantiates self, contact_list = []
    def __init__(self):
        pass

    #add
    #params -> contact: Contact
    #returns -> none
    #sides -> appends contact to self.contacts_list
    def add(self, contact):
        pass

    #update_contacts
    #params -> list of diary entries: List
    #returns -> none
    #sides -> creates new Contact for each phone number found in diary entries, and appends them to self.contact_list
    def update_contacts(self, entries):
        pass

    #get_contact_list
    #params -> none
    #returns -> self.contact_list, after updating
    #sides -> none
    def get_contact_list(self):
        pass

class TaskList():
    #init
    #params -> none
    #returns -> none
    #sides -> instantiates self, self.task_list = []
    def __init__(self):
        pass

    #add
    #params -> task : Task
    #returns -> none
    #sides -> appends task to task_list
    def add(self, task):
        pass
    
    #get_tasks
    #params -> none
    #returns -> self.task_list
    #sides -> none
    def get_tasks(self):
        pass

    #complete_all
    #params -> none
    #returns -> none
    #sides -> set all tasks in task_list to complete
    def complete_all(self):
        pass

    #incomplete_all
    #params -> none
    #returns -> none
    #sides -> set all tasks in task_list to incomplete
    def incomplete_all(self):
        pass


class Task():
    #init
    #params -> task: str
    #returns -> none
    #sides -> instantiate self
    def __init__(self):
        pass

    #get_task
    #params -> none
    #returns -> task
    #sides -> none
    def get_task():
        pass

    #mark_complete
    #params -> none
    #returns -> none
    #sides -> set self.complete to True
    def mark_complete():
        pass

    #mark_incomplete
    #params -> none
    #returns -> none
    #sides -> set self.complete to False
    def mark_cinomplete():
        pass




```
## 3. Create Examples as Tests

_Make a list of examples of how the class will behave in different situations._

``` python
# EXAMPLE

"""
Given a name and a task
#remind reminds the user to do the task
"""
reminder = Reminder("Kay")
reminder.remind_me_to("Walk the dog")
reminder.remind() # => "Walk the dog, Kay!"

"""
Given a name and no task
#remind raises an exception
"""
reminder = Reminder("Kay")
reminder.remind() # raises an error with the message "No task set."

"""
Given a name and an empty task
#remind still reminds the user to do the task, even though it looks odd
"""
reminder = Reminder("Kay")
reminder.remind_me_to("")
reminder.remind() # => ", Kay!"
```

_Encode each example as a test. You can add to the above list as you go._

## 4. Implement the Behaviour

_After each test you write, follow the test-driving process of red, green, refactor to implement the behaviour._
